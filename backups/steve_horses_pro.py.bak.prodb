#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# PF-35 Mach++ v4 — Pro board (clean replacement)
# - majors-only tracks
# - scratches removed (API + manual file)
# - TRAIN model + signals + DB nudges
# - market% with live→willpays→history→ML fallback
# - non-flat handicapping fallback
# - exacta "Anchor on Top" helper
# - PRO / PRO+TRAIN / PRO+DB / PRO+TRAIN+DB badges

from __future__ import annotations

import os, ssl, json, html, base64, re, math, statistics, hashlib
from pathlib import Path
from datetime import date, datetime
from urllib.request import Request, urlopen
from urllib.parse import urlencode
from collections import defaultdict
from typing import Dict, List, Optional, Tuple, Any, Iterable

# ---------------- Paths & version ----------------
VERSION = "PF-35 Mach++ v4"
HOME = Path.home()
BASE = HOME / "Desktop" / "SteveHorsesPro"
OUT_DIR = BASE / "outputs"; LOG_DIR = BASE / "logs"; IN_DIR = BASE / "inputs"
MODEL_DIR = BASE / "models"; DATA_DIR = BASE / "data"; SIG_DIR = BASE / "signals"
SCR_DIR = DATA_DIR / "scratches"
for d in (BASE, OUT_DIR, LOG_DIR, IN_DIR, MODEL_DIR, DATA_DIR, SIG_DIR, SCR_DIR):
    d.mkdir(parents=True, exist_ok=True)

def log(msg: str) -> None:
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        (LOG_DIR / "run.log").open("a", encoding="utf-8").write(f"[{ts}] {msg}\n")
    except Exception:
        pass

# ---------------- Track scope (majors only) ----------------
MAJOR_TRACKS = {
    "Saratoga","Del Mar","Santa Anita","Santa Anita Park","Gulfstream Park","Keeneland",
    "Churchill Downs","Belmont at the Big A","Woodbine","Kentucky Downs",
    "Parx Racing","Monmouth Park","Fair Grounds","Oaklawn Park","Tampa Bay Downs",
}

# ---------------- API ----------------
RUSER = os.getenv('RACINGAPI_USER') or os.getenv('RACINGAPI_USER'.upper())
RPASS = os.getenv('RACINGAPI_PASS') or os.getenv('RACINGAPI_PASS'.upper())
API_BASE = os.getenv("RACING_API_BASE", "https://api.theracingapi.com").rstrip("/")
CTX = ssl.create_default_context()

EP_MEETS = "/v1/north-america/meets"
EP_ENTRIES_BY_MEET = "/v1/north-america/meets/{meet_id}/entries"
EP_RESULTS_BY_RACE = "/v1/north-america/races/{race_id}/results"
EP_ODDS_HISTORY    = "/v1/north-america/races/{race_id}/odds_history"
EP_CONDITION_BY_RACE = "/v1/north-america/races/{race_id}/condition"
EP_WILLPAYS          = "/v1/north-america/races/{race_id}/willpays"

def _get(path, params=None):
    url = API_BASE + path + ("?" + urlencode(params) if params else "")
    req = Request(url, headers={"User-Agent": "Mozilla/5.0"})
    if RUSER and RPASS:
        tok = base64.b64encode(f"{RUSER}:{RPASS}".encode()).decode()
        req.add_header("Authorization", "Basic " + tok)
    with urlopen(req, timeout=30, context=CTX) as r:
        return json.loads(r.read().decode("utf-8","replace"))

def safe_get(path, params=None, default=None):
    try:
        return _get(path, params)
    except Exception as e:
        log(f"[api] GET fail {path}: {e}")
        return default

# ---------------- Utilities ----------------
def g(d:dict,*ks,default=None):
    for k in ks:
        if isinstance(d,dict) and k in d and d[k] not in (None,""):
            return d[k]
    return default

def _to_float(v, default=None):
    try:
        if v in (None,""): return default
        if isinstance(v,(int,float)): return float(v)
        s=str(v).strip()
        m=re.fullmatch(r"(\d+)\s*[/\-:]\s*(\d+)", s)
        if m:
            num, den = float(m.group(1)), float(m.group(2))
            if den!=0: return num/den
        return float(s)
    except:
        return default

def parse_frac_or_dec(s):
    if s is None: return (None,None)
    t=str(s).strip().lower()
    if t in ("evs","even","evens"): return (2.0,0.5)
    m=re.fullmatch(r"(\d+)\s*[/\-:]\s*(\d+)", t)
    if m:
        num,den=float(m.group(1)),float(m.group(2))
        if den>0: return (1.0+num/den, 1.0/den)
    try:
        dec=float(t)
        if dec>1.0: return (dec,1.0/dec)
    except: pass
    return (None,None)

def _to_dec_odds(v, default=None):
    if v in (None,""): return default
    if isinstance(v,(int,float)):
        f=float(v); return f if f>1 else default
    dec,_=parse_frac_or_dec(v); return dec if dec and dec>1 else default

def implied_from_dec(dec):
    if not dec or dec<=1: return None
    return 1.0/dec

def odds_formats(dec: float) -> str:
    if not dec or dec<=1: return "—"
    v=dec-1.0; best="—"; err=9e9
    for den in (1,2,3,4,5,6,8,10,12,16,20,32):
        num=round(v*den); e=abs(v-num/den)
        if e<err: err, best = e, f"{int(num)}/{int(den)}"
    payout = math.floor((2*dec)*100)/100.0
    return f"{best} • ${payout:0.2f} • {dec:.2f}"

def prg_num(r): 
    return str(g(r,"program_number","program","number","pp","post_position","horse_number","saddle","saddle_number") or "")

def horse_name(r): 
    return g(r,"horse_name","name","runner_name","runner","horse","horseName") or "Unknown"

def race_num(rc, idx): 
    return g(rc,"race_number","raceNo","race_num","number","race","rno") or idx

def get_surface(rc): 
    return str(g(rc,"surface","track_surface","course","courseType","trackSurface","surf") or "").lower()

def _surface_key(s: str) -> str:
    s = (s or "").lower()
    if "turf" in s: return "turf"
    if "synt" in s or "tapeta" in s or "poly" in s: return "synt"
    return "dirt"

def get_distance_y(rc) -> Optional[int]:
    d=g(rc,"distance_yards","distance","dist_yards","yards","distanceYards","distance_y")
    if d is not None:
        try: return int(float(d))
        except: pass
    m=g(rc,"distance_meters","meters","distanceMeters")
    if m is not None:
        try: return int(float(m)*1.09361)
        except: pass
    return None

def get_rail(rc): 
    return _to_float(g(rc,"rail","rail_setting","railDistance","rail_distance","turf_rail"), default=0.0)

def get_minutes_to_post(rc): 
    return _to_float(g(rc,"minutes_to_post","mtp","minutesToPost"), default=None)

def get_speed(r): 
    return _to_float(g(r,"speed","spd","last_speed","lastSpeed","best_speed","bestSpeed","fig","speed_fig","brz","beyer"), default=None)

def get_early_pace(r): 
    return _to_float(g(r,"pace","ep","early_pace","earlyPace","runstyle","style","quirin"), default=None)

def get_late_pace(r): 
    return _to_float(g(r,"lp","late_pace","closer","finishing_kick","lateSpeed"), default=None)

def get_class(r): 
    return _to_float(g(r,"class","cls","class_rating","classRating","par_class","parClass"), default=None)

def morning_line_decimal(r):
    v = g(r,"morning_line","ml","ml_odds","morningLine","morningLineOdds","morning_line_decimal","mlDecimal","programMorningLine")
    return _to_dec_odds(v, None)

def live_decimal(r):
    v = g(r,"live_odds","odds","currentOdds","current_odds","liveOdds","market","price","decimal_odds","winOdds","oddsDecimal")
    return _to_dec_odds(v, None)

# API pulls
def fetch_meets(iso_date): 
    return safe_get(EP_MEETS, {"start_date": iso_date, "end_date": iso_date}, default={"meets":[]})

def fetch_entries(meet_id): 
    return safe_get(EP_ENTRIES_BY_MEET.format(meet_id=meet_id), default={"races":[]})

def fetch_condition(race_id):
    d = safe_get(EP_CONDITION_BY_RACE.format(race_id=race_id), default={}) or {}
    return {
        "cond":   g(d, "condition","track_condition","dirt_condition","surface_condition") or
                  g(d, "turf_condition","turfCondition") or "",
        "takeout": _to_float(g(d, "takeout","win_takeout","takeout_win"), default=None)
    }

def fetch_odds_history(race_id):
    d=safe_get(EP_ODDS_HISTORY.format(race_id=race_id), default={}) or {}
    tl=g(d,"timeline","odds","history") or []
    per=defaultdict(lambda: {"last":None,"slope10":0.0,"var":0.0})
    if not isinstance(tl,list): return per
    bins=defaultdict(list)
    for x in tl:
        pr=str(g(x,"program","number","pp","saddle","saddle_number") or "")
        dec=_to_dec_odds(g(x,"dec","decimal","odds","price","decimal_odds"), None)
        ts=g(x,"ts","time","timestamp") or ""
        if pr and dec and dec>1: bins[pr].append((ts,dec))
    for pr, seq in bins.items():
        seq.sort(key=lambda z:z[0])
        last = seq[-1][1] if seq else None
        slope = 0.0; var=0.0
        if len(seq)>=3:
            a,b,c = seq[-3][1], seq[-2][1], seq[-1][1]
            slope = max(-1.0, min(1.0, (a - c) / max(2.0, a)))
        if len(seq)>=5:
            try: var = statistics.pvariance([v for _,v in seq[-5:]])
            except: var = 0.0
        per[pr] = {"last": last, "slope10": slope, "var": var}
    return per

def fetch_willpays(race_id):
    d = safe_get(EP_WILLPAYS.format(race_id=race_id), default={}) or {}
    prob = {}
    for it in g(d,"win_probables","probables","win","willpays") or []:
        pr  = str(g(it,"program","number","pp","saddle") or "")
        p   = _to_float(g(it,"impl_win","prob","p"), None)
        if not p:
            dec = _to_dec_odds(g(it,"price","odds","decimal_odds"), None)
            if dec and dec > 1: p = 1.0/dec
        if pr and p and 0.0 < p < 1.0:
            prob[pr] = p
    pool = _to_float(g(d,"pool","win","win_pool","winPool"), default=None)
    return {"impl": prob, "win_pool": pool}

# ---------------- SCRATCHES ----------------
SCR_FLAG_VALUES = {"scr", "scratched", "scratch", "wd", "withdrawn", "dns", "dnp", "dq"}
SCR_BOOL_KEYS = ("is_scratched","isScratched","scratched_flag","scratchedFlag","withdrawn","scr")

def is_scratched_runner(r):
    status = str(g(r, "status", "runnerStatus", "entry_status", "entryStatus", "condition") or "").lower().strip()
    if status in SCR_FLAG_VALUES:
        return True
    for k in SCR_BOOL_KEYS:
        v = g(r, k)
        if isinstance(v, bool) and v: return True
        if isinstance(v, str) and v.lower().strip() in ("1","true","yes","y"): return True
    tag = str(g(r, "scratch_indicator", "scratchIndicator") or "").lower().strip()
    if tag in ("1","true","yes","y","scr"): return True
    return False

def _scr_path_for(date_iso: str) -> Path:
    return SCR_DIR / f"{date_iso}.txt"

def save_scratch_template(date_iso: str, cards_map: dict) -> Path:
    path = _scr_path_for(date_iso)
    if path.exists(): return path
    lines = [
        f"# Manual scratches for {date_iso}",
        "# Format: Track Name|RaceNumber|prog,prog",
        "# Example: Del Mar|2|4,7",
    ]
    for track, races in cards_map.items():
        for rc in races:
            rno = g(rc, "race_number", "race", "number", "raceNo") or ""
            try: rno = int(re.sub(r"[^\d]", "", str(rno)))
            except: continue
            lines.append(f"{track}|{rno}|")
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    log(f"[scr] created template -> {path}")
    return path

def load_manual_scratches(date_iso: str) -> dict:
    path = _scr_path_for(date_iso)
    out = {}
    if not path.exists(): return out
    for raw in path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"): continue
        try:
            track, rno_s, progs = [x.strip() for x in line.split("|", 3)[:3]]
            rno = int(re.sub(r"[^\d]","", rno_s))
            lst = [p.strip() for p in re.split(r"[,\s]+", progs) if p.strip()]
            if lst:
                out.setdefault(track, {}).setdefault(rno, set()).update(lst)
        except:
            pass
    return out

def apply_scratches(cards_map: dict, auto_scr: dict, manual_scr: dict):
    auto_races = 0; manual_races = 0
    for track, races in cards_map.items():
        a = auto_scr.get(track, {})
        m = manual_scr.get(track, {})
        for rc in races:
            rno_raw = g(rc,"race_number","race","number","raceNo")
            try: rno = int(re.sub(r"[^\d]","", str(rno_raw)))
            except: continue
            set_auto = set(a.get(rno, set())); set_man  = set(m.get(rno, set()))
            use = set_man if set_man else set_auto
            runners = rc.get("runners") or rc.get("entries") or []
            for r in runners:
                if is_scratched_runner(r): r["scratched"] = True
            if use:
                if set_man: manual_races += 1
                if set_auto: auto_races += 1
                for r in runners:
                    if prg_num(r) in use:
                        r["scratched"] = True
            rc["runners"] = [r for r in runners if not r.get("scratched")]
    return {"auto_races": auto_races, "manual_races": manual_races}

# ---------------- Model load ----------------
MODEL: Dict[str, Any] = {"buckets":{}, "global":{}, "pars":{}, "calib":{}, "meta":{"version":"1"}}
def model_path(): return MODEL_DIR / "model.json"

def load_model():
    global MODEL
    p = model_path()
    if not p.exists():
        log(f"[model] not found -> {p}")
        return False
    try:
        MODEL = json.loads(p.read_text(encoding="utf-8"))
        log(f"[model] loaded -> {p}")
        return True
    except Exception as e:
        log(f"[model] load fail: {e}")
        return False

# ---------------- Features aligned to TRAIN ----------------
FEATS = [
    "speed","ep","lp","class","trainer_win","jockey_win","combo_win",
    "field_size","rail","ml_dec","live_dec","minutes_to_post","last_days","weight",
    "post_bias","surface_switch","equip_blinker","equip_lasix","pace_fit","class_par_delta"
]

def _sigmoid(z):
    z = max(-50.0, min(50.0, z)); return 1.0 / (1.0 + math.exp(-z))

def _standardize_apply(x, stat):
    mu,sd=stat.get("mu",[0.0]*len(x)), stat.get("sd",[1.0]*len(x))
    return [(xi - mu[j])/(sd[j] if sd[j]!=0 else 1.0) for j,xi in enumerate(x)]

def _post_bias(track, surface, yards, post_str):
    try: pp=int(re.sub(r"\D","", str(post_str) or "")) if post_str is not None else None
    except: pp=None
    surf=_surface_key(surface); base=0.0
    if surf=="turf" and pp and pp>=10: base -= 0.02
    if surf=="dirt" and pp and pp<=2: base += 0.01
    return base

def compute_class_pars_rowkey(track, surf, yards):
    def bucket(yards: Optional[int]) -> str:
        if not yards: return "unk"
        if yards < 1320:  return "<6f"
        if yards < 1540:  return "6f"
        if yards < 1760:  return "7f"
        if yards < 1980:  return "1mi"
        if yards < 2200:  return "8.5f"
        if yards < 2420:  return "9f"
        return "10f+"
    return f"{track}|{_surface_key(surf)}|{bucket(yards)}"

def build_feature_row_for_predict(track, rc, r, pars, pace_prior=0.0):
    speed=(get_speed(r) or 0.0)
    ep   =(get_early_pace(r) or 0.0)
    lp   =(get_late_pace(r) or 0.0)
    cls  =(get_class(r) or 0.0)
    tr   =(_to_float(g(r,"trainer_win_pct","trainerWinPct"), None) or 0.0)
    jk   =(_to_float(g(r,"jockey_win_pct","jockeyWinPct"), None) or 0.0)
    tj   =(_to_float(g(r,"tj_win","combo_win"), None) or 0.0)
    field=(len(rc.get("runners") or rc.get("entries") or [])) or 8
    rail =(get_rail(rc) or 0.0)
    ml   = morning_line_decimal(r) or 0.0
    live = (live_decimal(r) or 0.0)
    mtp  =(get_minutes_to_post(rc) or 15.0)
    dsl  = _to_float(g(r,"days_since","dsl","daysSince","layoffDays","last_start_days"), None) or 25.0
    wt   = _to_float(g(r,"weight","carried_weight","assigned_weight","wt","weight_lbs"), None) or 120.0
    surf = get_surface(rc); yards=get_distance_y(rc)
    key  = compute_class_pars_rowkey(track, surf, yards)
    par  = MODEL.get("pars", {}).get(key, {"spd":80.0,"cls":70.0})
    class_par_delta = (cls - par["cls"])/20.0 + (speed - par["spd"])/25.0
    pbias=_post_bias(track, surf, yards, prg_num(r))
    surf_switch = 1.0 if (str(g(r,"prev_surface","last_surface") or "").lower() and get_surface(rc) and (g(r,"prev_surface","last_surface")!=surf)) else 0.0
    bl,lx = (0.0,0.0)
    def S(x,a): return (x or 0.0)/a
    pace_fit = ((ep or 0.0) - 92.0)/20.0 if ep else 0.0
    return [
        S(speed,100.0), S(ep,120.0), S(lp,120.0), S(cls,100.0),
        S(tr,100.0), S(jk,100.0), S(tj,100.0),
        S(field,12.0), S(rail,30.0), S(ml,10.0), S(live,10.0), S(mtp,30.0), S(dsl,60.0), S(wt,130.0),
        pbias, surf_switch, bl, lx, pace_fit, class_par_delta
    ]

# ---------------- Horse DB (optional, read-only) ----------------
HORSE_DB_AVAILABLE = False
try:
    from db_horses import get_recent_runs as _horse_get_recent_runs  # type: ignore
    HORSE_DB_AVAILABLE = True
except Exception as _e:
    log(f"[horse-db] not available: {_e}")

def _recent_runs_from_db(runner: dict, max_n: int = 6) -> list:
    if not HORSE_DB_AVAILABLE: return []
    try:
        import unicodedata as _ud
        def _normalize_name_db(name: str) -> str:
            s = _ud.normalize("NFKD", str(name)).encode("ascii","ignore").decode("ascii")
            s = s.lower(); s = re.sub(r"[^a-z0-9]+", " ", s)
            s = re.sub(r"\b(the|a|an|of|and|&)\b", " ", s)
            return re.sub(r"\s+", " ", s).strip()
        def _horse_key_db(name: str, yob: Optional[int]=None, country: Optional[str]=None) -> str:
            base = _normalize_name_db(name)
            tail = []
            if yob:
                try: tail.append(str(int(yob)))
                except: pass
            if country: tail.append(str(country).strip().upper())
            return base + ("|" + "|".join(tail) if tail else "")
        def _runner_yob_country(r: dict) -> Tuple[Optional[int], Optional[str]]:
            yob = _to_float(g(r, "yob","year_of_birth","foaled","yearBorn"), None)
            try: yob = int(yob) if yob and yob > 1900 else None
            except: yob = None
            country = g(r, "country","birth_country","bred","bredIn","origin","countryCode")
            if isinstance(country, str) and country.strip():
                country = country.strip().upper()
            else:
                country = None
            return yob, country
        name = horse_name(runner)
        yob, country = _runner_yob_country(runner)
        key = _horse_key_db(name, yob, country)
        runs = _horse_get_recent_runs(key, n=max_n) or []
        return runs if isinstance(runs, list) else []
    except Exception as e:
        log(f"[horse-db] get runs failed for {horse_name(runner)}: {e}")
        return []

def apply_horse_db_adjustments(track: str, rc: dict, runners: list, p_vec: list[float]) -> Tuple[list[float], list[str]]:
    if not runners or not p_vec or len(runners) != len(p_vec) or not HORSE_DB_AVAILABLE:
        return p_vec, [""] * len(runners)
    adj = list(p_vec); flags=[]
    alpha = float(os.getenv("HORSE_DB_ALPHA", "0.20")); alpha = max(0.0, min(0.5, alpha))
    shifts=[]
    for i, r in enumerate(runners):
        runs = _recent_runs_from_db(r, max_n=6)
        if not runs:
            flags.append(""); continue
        spd = [ _to_float(x.get("speed"), None) for x in runs if x.get("speed") not in (None,"") ]
        cls = [ _to_float(x.get("class_"), None) for x in runs if x.get("class_") not in (None,"") ]
        pos = [ _to_float(x.get("result_pos"), None) for x in runs if x.get("result_pos") not in (None,"") ]
        spd=[v for v in spd if isinstance(v,(int,float))]; cls=[v for v in cls if isinstance(v,(int,float))]
        pos=[int(v) for v in pos if isinstance(v,(int,float)) and v>0]
        # simple form score
        def _trend(xs):
            if not xs: return 0.0
            m=statistics.mean(xs); s=statistics.pstdev(xs) if len(xs)>1 else 1.0; 
            if s<1e-6: s=1.0
            z=max(-2.5, min(2.5, (xs[0]-m)/s))
            return z/2.5
        score = 0.5*_trend(spd) + 0.3*_trend(cls)
        if pos:
            wn=sum(1 for p in pos if p==1); plc=sum(1 for p in pos if p==2); show=sum(1 for p in pos if p==3)
            score += min(0.30, (wn*1.0 + plc*0.6 + show*0.35)/max(1,len(pos)) * 0.30)
        score=max(-0.45, min(0.45, score))
        mult = math.exp(0.85*score)
        bump = 1.0 + alpha * (mult - 1.0)
        adj[i] = max(1e-6, min(0.999, adj[i]*bump))
        flags.append("DB:{}r".format(len(runs)))
        shifts.append(bump)
    s=sum(adj)
    if s>0: adj=[x/s for x in adj]
    try:
        track_name=str(track); rno=g(rc,"race_number","race","number","raceNo") or "?"
        log(f"[horse-db] {track_name} R{rno} alpha={alpha} shifts={','.join('{:.3f}'.format(x) for x in shifts)}")
    except Exception:
        pass
    return adj, flags

# ---------------- Handicapping fallback ----------------
def pace_style(r):
    ep = get_early_pace(r) or 0.0; lp = get_late_pace(r)  or 0.0
    if ep - lp >= 8:   return "E"
    if ep - lp >= 3:   return "EP"
    if lp - ep >= 5:   return "S"
    return "P"

def zsc(xs):
    if not xs: return []
    m=statistics.mean(xs); s=statistics.pstdev(xs) if len(xs)>1 else 0.0
    if s<1e-6: s=1.0
    return [(x-m)/s for x in xs]

def handcrafted_scores(track, rc, runners):
    spd=[get_speed(r) or 0.0 for r in runners]
    ep =[get_early_pace(r) or 0.0 for r in runners]
    lp =[get_late_pace(r) or 0.0 for r in runners]
    cls=[get_class(r) or 0.0 for r in runners]
    spdZ,epZ,lpZ,clsZ=zsc(spd),zsc(ep),zsc(lp),zsc(cls)
    w_spd,w_ep,w_lp,w_cls=1.0,0.55,0.30,0.45
    trR=[(_to_float(g(r,"trainer_win_pct","trainerWinPct"),0.0) or 0.0)/100.0 for r in runners]
    jkR=[(_to_float(g(r,"jockey_win_pct","jockeyWinPct"),0.0)  or 0.0)/100.0 for r in runners]
    tjR=[(_to_float(g(r,"tj_win","combo_win"),0.0)           or 0.0)/100.0 for r in runners]
    scores=[]
    for i,r in enumerate(runners):
        s=w_spd*spdZ[i] + w_ep*epZ[i] + w_lp*lpZ[i] + w_cls*clsZ[i] + 0.25*trR[i] + 0.18*jkR[i] + 0.10*tjR[i]
        seed=f"{track}|{race_num(rc,0)}|{prg_num(r)}|{horse_name(r)}"
        h=hashlib.sha1(seed.encode()).hexdigest()
        s+=(int(h[:6],16)/0xFFFFFF - 0.5)*0.03
        scores.append(s)
    return scores

def field_temp(n): return 0.80 if n>=12 else (0.72 if n>=10 else (0.66 if n>=8 else 0.60))

def softmax(zs, temp):
    if not zs: return []
    m=max(zs); exps=[math.exp((z-m)/max(1e-6,temp)) for z in zs]; s=sum(exps)
    return [e/s for e in exps] if s>0 else [1.0/len(zs)]*len(zs)

def anti_flat_separation(track, rc, runners, p_model):
    if not p_model: return p_model
    n=len(p_model)
    if n<=2: return p_model
    rng = (max(p_model)-min(p_model)) if p_model else 0.0
    var = statistics.pvariance(p_model) if len(p_model)>1 else 0.0
    if rng >= 0.04 or var >= 1e-5:
        return p_model
    zs = handcrafted_scores(track, rc, runners)
    t  = max(0.45, field_temp(n)-0.10)
    pz = softmax(zs, temp=t)
    mix = 0.70
    blended = [max(1e-6, min(0.999, mix*pz[i] + (1-mix)*p_model[i])) for i in range(n)]
    s=sum(blended)
    return [x/s for x in blended] if s>0 else p_model

# ---------------- Model probabilities ----------------
def probabilities_from_model_only(track, rc, runners):
    ps=[]; ok=True
    pars = MODEL.get("pars", {})
    # pace prior per race (mean EP)
    eps=[get_early_pace(x) or 0.0 for x in runners]
    pace_prior=(statistics.mean(eps)-92.0)/20.0 if eps else 0.0
    key=lambda: compute_class_pars_rowkey(track, get_surface(rc), get_distance_y(rc))
    entry= MODEL.get("buckets",{}).get(key()) or MODEL.get("global")
    if not entry or not entry.get("w"):
        ok=False
    else:
        for r in runners:
            x = build_feature_row_for_predict(track, rc, r, pars, pace_prior)
            xs = _standardize_apply(x, entry.get("stat", {"mu":[0.0]*len(FEATS),"sd":[1.0]*len(FEATS)}))
            z = entry.get("b",0.0) + sum(wj*xj for wj,xj in zip(entry["w"], xs))
            ps.append(max(1e-6,min(0.999,_sigmoid(z))))
    if ok and ps:
        s=sum(ps); ps=[p/s for p in ps] if s>0 else [1.0/len(ps)]*len(ps)
        ps = anti_flat_separation(track, rc, runners, ps)
        return ps
    # fallback handicapping
    zs = handcrafted_scores(track, rc, runners)
    t = field_temp(len(runners))
    ps = softmax(zs, temp=t)
    if len(ps) >= 12:
        ps=[max(0.003,p) for p in ps]; s=sum(ps); ps=[p/s for p in ps]
    return ps

def blend_with_market_if_present(p_model, p_market, minutes_to_post):
    if not p_market or all(x is None for x in p_market):
        return p_model
    pm = [0.0 if (x is None or x <= 0) else float(x) for x in p_market]
    sm = sum(pm); pm = [x/sm if sm > 0 else 0.0 for x in pm]
    alpha = 0.93 if (minutes_to_post is None or minutes_to_post >= 20) else (0.88 if minutes_to_post >= 8 else 0.80)
    blended=[(max(1e-9,m)**alpha)*(max(1e-9,mk)**(1.0-alpha)) for m,mk in zip(p_model, pm)]
    s=sum(blended)
    return [b/s for b in blended] if s>0 else p_model

# ---------------- Cards (majors only) + scratches ----------------
def build_cards(iso_date):
    meets = fetch_meets(iso_date).get("meets", [])
    cards = {}; auto_lines=[]
    def only_digits(s: str) -> str: return re.sub(r"\D", "", s or "")
    for m in meets:
        track = g(m,"track_name","track","name") or "Track"
        if track not in MAJOR_TRACKS: continue
        mid = g(m,"meet_id","id","meetId")
        if not mid: continue
        try:
            entries = fetch_entries(mid)
            races = entries.get("races") or entries.get("entries") or []
            for r_idx, r in enumerate(races, 1):
                r["runners"]=r.get("runners") or r.get("entries") or r.get("horses") or r.get("starters") or []
                for rr in r["runners"]:
                    if is_scratched_runner(rr): rr["scratched"]=True
                rno_raw = g(r,"race_number","race","number","raceNo") or r_idx
                try: rno = int(re.sub(r"[^\d]","", str(rno_raw)))
                except: rno = r_idx
                scr_prog=[prg_num(x) for x in r["runners"] if x.get("scratched")]
                scr_prog=[n for n in scr_prog if n]
                if scr_prog:
                    nums_sorted = sorted(scr_prog, key=lambda z: int(only_digits(z) or "0"))
                    nums_str = ", ".join(nums_sorted)
                    auto_lines.append(f"{track}|{rno}|{nums_str}")
            if races: cards[track] = races
        except Exception as e:
            log(f"[entries] fetch failed for {track}: {e}")
    if auto_lines:
        p = IN_DIR / f"scratches_AUTO_{iso_date}.txt"
        p.write_text("# Auto-scratches\n" + "\n".join(auto_lines) + "\n", encoding="utf-8")
    return cards, auto_lines

def build_cards_and_scratches(iso_date):
    cards, auto_lines = build_cards(iso_date)
    save_scratch_template(iso_date, cards)
    manual_scr = load_manual_scratches(iso_date)
    auto_scr_map = defaultdict(lambda: defaultdict(set))
    for line in auto_lines:
        try:
            track, rno_s, progs = [x.strip() for x in line.split("|", 3)[:3]]
            rno = int(re.sub(r"[^\d]","", rno_s))
            lst=[p.strip() for p in progs.split(",") if p.strip()]
            for pnum in lst: auto_scr_map[track][rno].add(pnum)
        except: pass
    scr_summary = apply_scratches(cards, auto_scr_map, manual_scr)
    auto_summary={"auto_count": sum(len(x.split('|')[2].split(',')) for x in auto_lines) if auto_lines else 0}
    return cards, scr_summary, auto_summary

# ---------------- Train signals ----------------
def load_train_signals(meet_key: str) -> Dict[Tuple[str, str], Dict[str, Any]]:
    """
    meet_key = '<Track>|YYYY-MM-DD'
    Looks in both: DATA/signals/Track|YYYY-MM-DD.json and signals/YYYY-MM-DD__Track.json
    """
    try:
        track_raw, day = meet_key.split("|", 1)
    except Exception:
        return {}
    sig_new = (DATA_DIR / "signals" / f"{track_raw}|{day}.json")
    sig_old = (SIG_DIR  / f"{day}__{track_raw}.json")
    path = sig_new if sig_new.exists() else (sig_old if sig_old.exists() else None)
    if not path: return {}
    try:
        raw = json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        log(f"[train] signals load fail {meet_key} from {path.name}: {e}")
        return {}
    def _norm_race(x) -> str:
        s = str(x or "").strip()
        if not s: return ""
        m = re.search(r"(\d+)", s)
        return m.group(1) if m else s
    out = {}
    for row in raw if isinstance(raw, list) else []:
        rno = _norm_race(row.get("race") or row.get("r") or "")
        pgm = str(row.get("program") or row.get("pgm") or row.get("num") or "").strip()
        if not rno or not pgm:
            continue
        out[(rno, pgm)] = {
            "used":  bool(row.get("used", True)),
            "score": float(row.get("p", 0.0) or 0.0),
            "wager": float(row.get("wager", 0.0) or 0.0),
            "flags": list(row.get("flags") or []),
            "why":   str(row.get("why") or "TRAIN prior"),
        }
    return out

# ---------------- WHY pack (SpeedForm/ClassΔ/Bias text) ----------------
def _safe_mean(xs):
    try: return statistics.mean(xs) if xs else 0.0
    except Exception: return 0.0
def _safe_pstdev(xs):
    try:
        if not xs or len(xs) <= 1: return 0.0
        s = statistics.pstdev(xs); return s if s > 1e-6 else 0.0
    except Exception: return 0.0
def _zscore_or_neutral(xs, n):
    s = _safe_pstdev(xs)
    if s <= 1e-6: return [0.0]*n, [50]*n
    m = _safe_mean(xs); z = [(x - m)/s for x in xs]
    order = sorted(z); pct=[]
    for v in z:
        k = sum(1 for q in order if q <= v)
        p = int(round(100.0*(k-0.5)/max(1, len(z))))
        pct.append(max(1, min(99, p)))
    return z, pct
def _arrow(p):
    return "↑" if p >= 67 else ("↗" if p >= 55 else ("→" if p > 45 else ("↘" if p >= 33 else "↓")))
def why_feature_pack(track: str, rc: dict, runners: List[dict]):
    surf = get_surface(rc); yards = get_distance_y(rc)
    key  = compute_class_pars_rowkey(track, surf, yards)
    par  = MODEL.get("pars", {}).get(key, {"spd": 80.0, "cls": 70.0})
    speed = [get_speed(r) or 0.0 for r in runners]
    klass = [get_class(r) or 0.0 for r in runners]
    bias_raw = []
    for r in runners:
        pb = _post_bias(track, surf, yards, prg_num(r))
        bias_raw.append(pb)
    sf_raw    = [ (sp - par["spd"])/25.0 + (cl - par["cls"])/20.0 for sp, cl in zip(speed, klass) ]
    class_raw = [ (cl - par["cls"])/20.0 for cl in klass ]
    n = len(runners)
    sf_z,   sf_pct   = _zscore_or_neutral(sf_raw, n)
    cls_z,  cls_pct  = _zscore_or_neutral(class_raw, n)
    bia_z,  bia_pct  = _zscore_or_neutral(bias_raw, n)
    why=[]; tips=[]
    for i in range(n):
        why.append("SpeedForm {} ({} pct), ClassΔ {} ({} pct), Bias {} ({} pct)".format(
            _arrow(sf_pct[i]), sf_pct[i], _arrow(cls_pct[i]), cls_pct[i], _arrow(bia_pct[i]), bia_pct[i]
        ))
        tips.append("SpeedForm {0:+0.2f}σ • ClassΔ {1:+0.2f}σ • Bias {2:+0.2f}σ".format(
            sf_z[i], cls_z[i], bia_z[i]
        ))
    return why, tips

# ---------------- Exacta helper ----------------
def _safe_list(xs: Iterable[Optional[float]]) -> List[float]:
    out = []
    for x in xs:
        try:
            f=float(x)
            if not (f>=0): f=0.0
            out.append(f)
        except: out.append(0.0)
    s=sum(out)
    return [v/s if s>0 else 0.0 for v in out]

def suggest_exactas(programs: List[str], p_final: List[float], field_size: int, takeout_win: Optional[float], cond: str, anchors: Optional[List[str]] = None) -> List[dict]:
    n = len(programs)
    if n < 2: return []
    P = _safe_list(p_final)
    idx = {programs[i]: i for i in range(n)}
    winners = list(programs)
    if anchors: winners = [a for a in anchors if a in idx] or winners
    T = takeout_win if isinstance(takeout_win,(int,float)) and 0 < takeout_win < 0.35 else 0.20
    pad_mult = float(os.getenv("EX_MIN_PAD_MULT", "1.35"))
    out = []
    for a in winners:
        ia = idx[a]; pA = max(1e-6, min(0.999, P[ia]))
        denom = max(1e-6, 1.0 - pA)
        for b in programs:
            if b == a: continue
            ib = idx[b]; pB = max(1e-6, min(0.999, P[ib]))
            p_ab = pA * (pB / denom) * 0.92
            if p_ab <= 0: continue
            fair = 2.0 * (1.0 / p_ab) * (1.0 - T)
            minp = fair * pad_mult
            out.append({"a": a, "b": b, "p_ij": p_ab, "fair_wp": fair, "min_wp": minp})
    out.sort(key=lambda r: -r["p_ij"])
    return out

# ---------------- Pricing / Kelly (display only for now) ----------------
def fair_and_minprice(p, field=None, takeout=None, cond=""):
    p = max(1e-6, min(0.999999, p))
    fair = 1.0 / p
    fs = field or 8
    size_adj = 0.012 * max(0, fs - 8)
    to = (takeout or 0.16)
    cond_adj = 0.0
    c = (cond or "").lower()
    if c in ("sloppy", "muddy", "yielding", "soft"):
        cond_adj += 0.02
    pad = 0.22 + size_adj + 0.5 * to + cond_adj
    min_odds = fair * (1.0 + pad)
    return fair, min_odds

# ---------------- Report build ----------------
def build_report(cards, iso_date, scr_summary):
    import html as _html
    parts = [("""<!doctype html><html><head><meta charset="utf-8"><title>{} — {}</title>
<style>
body{{font-family:-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px}}
table{{border-collapse:collapse;width:100%;margin:12px 0}}
th,td{{border:1px solid #ddd;padding:6px 8px;text-align:left;font-size:14px}}
th{{background:#f3f3f3}} .mono{{font-variant-numeric:tabular-nums}} .small{{color:#666;font-size:12px}}
.badge{{display:inline-block;background:#eef;border:1px solid #dde;border-radius:3px;padding:1px 6px;margin:0 2px}}
.badge.pro{{background:#eaffea}} .badge.train{{background:#e6f4ff}}
</style></head><body>""").format(VERSION, iso_date)]
    parts.append("<h1>{} <span class='small'>({})</span></h1>".format(VERSION, iso_date))
    parts.append("<p class='small'>Scratches — auto races: {}, manual races: {}</p>".format(scr_summary.get('auto_races',0), scr_summary.get('manual_races',0)))

    # PRIME/ACTION sections (kept but populated only if gating allows)
    parts.append("<h2>PRIME Board</h2><p class='small'>No plays met criteria.</p>")
    parts.append("<h2>ACTION Board</h2><p class='small'>No plays met criteria.</p>")

    # ---------- RACE SECTIONS ----------
    for track, races in cards.items():
        meet_key = "{}|{}".format(track, iso_date)
        train_signals = load_train_signals(meet_key)

        for idx_race, rc in enumerate(races, 1):
            rno = str(race_num(rc, idx_race))
            rid = str(g(rc,"race_id","id","raceId","raceID","uuid","uuid_str","eventId","event_id") or "")

            # pull aux (condition, odds history, willpays) if RID looks real
            cond = {"cond": "", "takeout": None}
            oh = {}; wp = {"impl": {}, "win_pool": None}
            vendor_rid_like = rid != "" and ("|" not in rid)
            if vendor_rid_like:
                try: cond = fetch_condition(rid) or cond
                except Exception as e: log(f"[aux] cond fail rid={rid}: {e}")
                try: oh = fetch_odds_history(rid) or oh
                except Exception as e: log(f"[aux] odds fail rid={rid}: {e}")
                try: wp = fetch_willpays(rid) or wp
                except Exception as e: log(f"[aux] willpays fail rid={rid}: {e}")

            runners = (rc.get("runners") or rc.get("entries") or [])
            runners = [r for r in runners if not r.get("scratched") and not is_scratched_runner(r)]
            if not runners:
                continue

            # Market vectors (dec + implied)
            hist_last = {k: v.get("last") for k, v in (oh or {}).items()}
            market_dec = []
            market_probs = []
            for r in runners:
                pr = prg_num(r)
                m_live = live_decimal(r)
                implied = wp.get("impl", {}).get(pr)
                m_wp = (1.0/float(implied)) if (implied and implied>0 and implied<1) else None
                m_hist = _to_dec_odds(hist_last.get(pr), None)
                m_ml = morning_line_decimal(r)
                cands = [x for x in (m_live, m_wp, m_hist, m_ml) if x is not None]
                mkt = min(cands) if cands else None
                market_dec.append(mkt)
                market_probs.append((1.0/mkt) if (mkt and mkt>1.0) else None)

            # Model + market + DB
            p_model = probabilities_from_model_only(track, rc, runners)
            m2p = get_minutes_to_post(rc) or 30.0
            p_after_market = blend_with_market_if_present(p_model, market_probs, m2p)
            p_final, db_flags = apply_horse_db_adjustments(track, rc, runners, p_after_market)

            # WHY
            why_strings, why_tips = why_feature_pack(track, rc, runners)

            # Build enriched rows
            field = len(runners)
            parts.append("<h2>{} — Race {}</h2>".format(_html.escape(track), rno))
            programs = [p for p in (prg_num(r) for r in runners) if p]
            # exacta (anchor on top = highest Win%)
            try:
                anchor = programs[p_final.index(max(p_final))] if programs and p_final else None
                ex_rows = suggest_exactas(programs=programs, p_final=p_final, field_size=field, takeout_win=cond.get("takeout"), cond=cond.get("cond") or "", anchors=[anchor] if anchor else None)
                if anchor and ex_rows:
                    legs = ", ".join(f"#{ex['b']}" for ex in ex_rows[:3])
                    parts.append(f"<p class='small'><b>Exacta (Anchor on Top):</b> <b>#{_html.escape(anchor)}</b> OVER {legs}</p>")
            except Exception as e:
                log(f"[exacta] fail {track} R{rno}: {e}")

            parts.append(
                "<table><thead><tr>"
                "<th>#</th><th>Horse</th>"
                "<th class='mono'>Win% (Final)</th>"
                "<th class='mono'>Market%</th>"
                "<th class='mono'>Edge</th>"
                "<th class='mono'>Fair</th>"
                "<th class='mono'>Min Price</th>"
                "<th class='mono'>Market</th>"
                "<th>Notes</th>"
                "<th>Source</th>"
                "<th class='mono'>Bet</th>"
                "</tr></thead><tbody>"
            )

            # write rows
            for i, r in enumerate(sorted(runners, key=lambda x: -p_final[runners.index(x)])):
                idx = runners.index(r)
                pF = p_final[idx]
                dec = market_dec[idx]
                imp = (1.0/dec) if dec and dec>1.0 else None
                fair, minp = fair_and_minprice(pF, field=field, takeout=cond.get("takeout"), cond=cond.get("cond"))
                edge_pp = (pF - (imp or 0.0)) if imp is not None else None

                # TRAIN signals badge + why blend
                tinfo = (train_signals.get((str(rno), prg_num(r))) or {})
                t_used = bool(tinfo.get("used"))
                t_score = tinfo.get("score", None)
                _why = (tinfo.get("why") or why_strings[idx])

                # badges
                source = "PRO"
                used_db = bool(db_flags[idx]) if (isinstance(db_flags, list) and idx < len(db_flags)) else False
                if t_used and used_db: source = "PRO+TRAIN+DB"
                elif t_used:          source = "PRO+TRAIN"
                elif used_db:         source = "PRO+DB"

                parts.append(
                    "<tr>" +
                    "<td class='mono'>{}</td>"
                    "<td>{}<div class='small'>{}</div></td>"
                    "<td class='mono'>{:.2f}%</td>"
                    "<td class='mono'>{}</td>"
                    "<td class='mono'>{}</td>"
                    "<td class='mono'>{}</td>"
                    "<td class='mono'>{}</td>"
                    "<td class='mono'>{}</td>"
                    "<td>{}</td>"
                    "<td><span class='badge {}'>{}</span></td>"
                    "<td class='mono'>—</td>".format(
                        html.escape(prg_num(r)),
                        html.escape(horse_name(r)),
                        html.escape(_why),
                        100.0*pF,
                        ("{:.1f}%".format(100.0*(imp or 0.0)) if imp is not None else "—"),
                        ("{:.1f} pp".format(100.0*edge_pp) if edge_pp is not None else "—"),
                        odds_formats(fair),
                        odds_formats(minp),
                        odds_formats(dec),
                        html.escape(""),
                        ("train" if source!="PRO" else "pro"), html.escape(source)
                    ) + "</tr>"
                )
            parts.append("</tbody></table>")

    parts.append("</body></html>")
    return "\n".join(parts)

# ---------------- Main ----------------
if __name__ == "__main__":
    iso_today = date.today().isoformat()
    log(f"[run] starting Pro for {iso_today}")

    model_loaded = load_model()
    if not model_loaded:
        log("[warn] model missing — using handicapping fallback where needed")

    cards, scr_summary, auto_summary = build_cards_and_scratches(iso_today)
    try:
        n_tracks = len(cards); n_races = sum(len(v) for v in cards.values())
        log(f"[cards] Tracks: {n_tracks}  Races: {n_races}")
    except Exception: pass

    html_out = build_report(cards, iso_today, scr_summary)
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    out_path = OUT_DIR / f"{iso_today}_horses_targets+full.html"
    out_path.write_text(html_out, encoding="utf-8")
    log(f"[ok] wrote {out_path}")