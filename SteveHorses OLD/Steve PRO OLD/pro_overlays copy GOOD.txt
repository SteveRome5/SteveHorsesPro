# pro_overlays.py
# Pluggable overlays: trainer/jockey, layoff cycle, pace pressure sim,
# day/track bias, shipper normalization, ensemble mixer.
# All nudges are gentle, bounded, and env-tunable.

from __future__ import annotations
import os, math, statistics, re
from typing import List, Dict, Tuple, Optional, Any

# ----------- Helpers -----------
def _to_float(v, default=None):
    try:
        if v in (None, ""): return default
        return float(v)
    except: return default

def _clamp01(x: float) -> float:
    return max(1e-6, min(0.999, x))

def _renorm(ps: List[float]) -> List[float]:
    s = sum(ps)
    return [p/s for p in ps] if s > 0 else ps

def _flag(flags: List[str], *xs: str) -> None:
    for x in xs:
        if x and x not in flags:
            flags.append(x)

def _pct(x: float) -> str:
    try: return "{:.0f}pct".format(100.0*x)
    except: return ""

def _mean(xs):
    try: return statistics.mean(xs) if xs else 0.0
    except: return 0.0

# ----------- Overlay 1: Trainer/Jockey -----------
def overlay_trainer_jockey(runners: List[dict], p: List[float]) -> Tuple[List[float], List[str]]:
    if not runners: return p, ["" for _ in p]
    alpha = _to_float(os.getenv("TJ_ALPHA", "0.12"), 0.12)  # strength
    floor = _to_float(os.getenv("TJ_FLOOR", "0.10"), 0.10)  # min win% to get boost (as fraction)
    boost_max = _to_float(os.getenv("TJ_BOOST_MAX", "0.18"), 0.18)  # cap

    out = list(p); flags = []
    for i, r in enumerate(runners):
        tw = (_to_float(r.get("trainer_win_pct"), None) or 0.0)/100.0
        jw = (_to_float(r.get("jockey_win_pct"),  None) or 0.0)/100.0
        tj = (_to_float(r.get("tj_win"),           None) or 0.0)/100.0

        base = max(tw, jw, tj)
        bump = 0.0
        if base >= floor:
            # convert into mild multiplicative bump
            # e.g. base 0.22 => up to ~1.10 before mixing by alpha
            bump = min(boost_max, 0.5*base)  # 0..~0.11 typical
        mult = 1.0 + alpha * bump
        out[i] = _clamp01(out[i] * mult)

        f = []
        if tw >= floor: f.append("TrnHot")
        if jw >= floor: f.append("JkyHot")
        if tj >= floor: f.append("TJHot")
        flags.append(" ".join(f))
    return _renorm(out), flags

# ----------- Overlay 2: Layoff / Cycle -----------
def _days_since(r):
    for k in ("days_since", "dsl", "daysSince", "layoffDays", "last_start_days"):
        v = r.get(k)
        f = _to_float(v, None)
        if f is not None: return f
    return None

def overlay_cycle(runners: List[dict], p: List[float]) -> Tuple[List[float], List[str]]:
    alpha = _to_float(os.getenv("CYCLE_ALPHA", "0.10"), 0.10)
    out = list(p); flags = []

    # rough cycle cues: 2nd/3rd off layoff ~ positive, >180d first back ~ negative
    for i, r in enumerate(runners):
        d = _days_since(r) or 0.0
        # optional field if you store "start_num_since_layoff"
        n_since = _to_float(r.get("start_since_layoff"), None)

        bump = 0.0; label = ""
        if d >= 150 and (not n_since or n_since <= 1):
            bump = -0.10; label = "1stOffLongLayoff"
        elif n_since in (2, 3):
            bump = 0.08; label = f"{int(n_since)}ndOffLayoff" if int(n_since)==2 else "3rdOffLayoff"
        elif 21 <= d <= 60:
            bump = 0.03; label = "Fresh"
        mult = 1.0 + alpha * bump
        out[i] = _clamp01(out[i] * mult)
        flags.append(label)
    return _renorm(out), flags

# ----------- Overlay 3: Pace Pressure Simulation -----------
def _ep(r):  # early pace proxy
    for k in ("pace","ep","early_pace","earlyPace","quirin","runstyle","style"):
        v = r.get(k)
        f = _to_float(v, None)
        if f is not None: return f
    return 0.0

def overlay_pace_pressure(runners: List[dict], p: List[float]) -> Tuple[List[float], List[str], dict]:
    if not runners: return p, ["" for _ in p], {"pressure": 0.0, "meltdown": 0.0}
    alpha = _to_float(os.getenv("PACE_ALPHA", "0.12"), 0.12)

    eps = [_ep(r) for r in runners]
    m = _mean(eps); sd = statistics.pstdev(eps) if len(eps)>1 else 0.0
    # crude pressure score: many horses well above mean → pressure↑
    count_fast = sum(1 for x in eps if x >= m + (sd if sd>0 else 5.0))
    pressure = min(2.0, count_fast / max(1.0, len(eps)/2.5))  # 0..~2
    meltdown = 1.0 if pressure >= 1.3 else (0.0 if pressure <= 0.5 else 0.5)

    # adjust: if pressure high → closers up, need-the-lead down; if soft → lone speed up
    out = list(p); flags = []
    for i, r in enumerate(runners):
        ep = _ep(r)
        # naive late-pace proxy from fields if present
        lp = _to_float(r.get("lp"), 0.0)
        style = "E" if ep - lp >= 8 else ("EP" if ep - lp >= 3 else ("S" if lp - ep >= 5 else "P"))

        bump = 0.0; tag = ""
        if pressure >= 1.2:
            if style == "S":    bump = 0.08; tag = "Closer+Meltdown"
            elif style == "E":  bump = -0.07; tag = "SpeedDuel"
        elif pressure <= 0.3:
            if style in ("E", "EP"): bump = 0.07; tag = "SoftPace+Speed"
        mult = 1.0 + alpha * bump
        out[i] = _clamp01(out[i] * mult)
        flags.append(tag)

    ctx = {"pressure": pressure, "meltdown": meltdown}
    return _renorm(out), flags, ctx

# ----------- Overlay 4: Day/Track Bias -----------
def overlay_bias(track: str, surface: str, rail: float, runners: List[dict], p: List[float]) -> Tuple[List[float], List[str]]:
    alpha = _to_float(os.getenv("BIAS_ALPHA", "0.08"), 0.08)
    out = list(p); flags = []
    is_turf = "turf" in (surface or "").lower()
    # simple heuristic: big turf rail favors outside, dirt sometimes favors inside low posts
    for i, r in enumerate(runners):
        post = 0
        for k in ("program_number","program","pp","post_position","saddle","saddle_number"):
            v = r.get(k)
            if v is not None:
                try:
                    post = int(re.sub(r"\D","", str(v)))
                except: pass
                break
        bump = 0.0; tag = ""
        if is_turf and rail and rail >= 20.0 and post >= 9:
            bump = 0.05; tag = "RailWideBias"
        elif (not is_turf) and post in (1,2):
            bump = 0.02; tag = "InsideBias?"
        mult = 1.0 + alpha * bump
        out[i] = _clamp01(out[i] * mult)
        flags.append(tag)
    return _renorm(out), flags

# ----------- Overlay 5: Shipper normalization -----------
def overlay_shipper(runners: List[dict], p: List[float]) -> Tuple[List[float], List[str]]:
    # If we detect "classy small-track monster shipping up", nudge down a hair; and vice versa
    alpha = _to_float(os.getenv("SHIP_ALPHA", "0.06"), 0.06)
    out = list(p); flags = []
    for i, r in enumerate(runners):
        last_track = (r.get("last_track") or r.get("prev_track") or "").lower()
        this_track = (r.get("track") or "").lower()
        bump = 0.0; tag = ""
        # crude map
        small = {"finger lakes","charlestown","mountaineer","penn national","canterbury","evangeline", "lone star"}
        big   = {"saratoga","del mar","belmont","aqueduct","churchill downs","keeneland","gulfstream"}
        if last_track in small and this_track in big:
            bump = -0.05; tag = "UpClassShip"
        elif last_track in big and this_track in small:
            bump = 0.04; tag = "DownClassShip"
        mult = 1.0 + alpha * bump
        out[i] = _clamp01(out[i] * mult)
        flags.append(tag)
    return _renorm(out), flags

# ----------- Overlay 6: Ensemble weight mixer -----------
def ensemble_mix(base: List[float], pieces: List[List[float]], weights: Optional[List[float]]=None) -> List[float]:
    # geometric blend to be robust to outliers
    if not pieces: return base
    ws = weights or [1.0/len(pieces)]*len(pieces)
    ws = [max(0.0, w) for w in ws]
    if sum(ws) <= 0: ws = [1.0/len(pieces)]*len(pieces)

    g = base[:]
    for j, comp in enumerate(pieces):
        if not comp or len(comp) != len(base): continue
        w = ws[j]
        g = [ _clamp01((b**(1.0-w)) * (c**w)) for b, c in zip(g, comp) ]
        g  = _renorm(g)
    return g

# ----------- Entry point: apply_all_overlays -----------
def apply_all_overlays(
    track: str,
    surface: str,
    rail: float,
    runners: List[dict],
    p_after_horse_db: List[float],
) -> Tuple[List[float], List[str], dict]:
    """
    Returns:
      probs, flags_per_runner, ctx (pace diagnostics)
    """
    # Always start from horse-DB adjusted probs supplied by caller
    base = list(p_after_horse_db)
    n = len(base)
    collect_flags = [[""] for _ in range(n)]  # will flatten at the end

    # 1) trainer/jockey
    if os.getenv("TJ_ENABLE", "1") == "1":
        pj, fj = overlay_trainer_jockey(runners, base)
    else:
        pj, fj = base, ["" for _ in base]

    # 2) cycle
    if os.getenv("CYCLE_ENABLE", "1") == "1":
        pc, fc = overlay_cycle(runners, base)
    else:
        pc, fc = base, [""]*n

    # 3) pace pressure
    if os.getenv("PACE_ENABLE", "1") == "1":
        pp, fp, ctx = overlay_pace_pressure(runners, base)
    else:
        pp, fp, ctx = base, [""]*n, {"pressure": 0.0, "meltdown": 0.0}

    # 4) bias
    if os.getenv("BIAS_ENABLE", "1") == "1":
        pb, fb = overlay_bias(track, surface, rail, runners, base)
    else:
        pb, fb = base, [""]*n

    # 5) shipper
    if os.getenv("SHIP_ENABLE", "1") == "1":
        ps, fs = overlay_shipper(runners, base)
    else:
        ps, fs = base, [""]*n

    # 6) ensemble mix (weights are env-tunable)
    wj = _to_float(os.getenv("W_TJ",   "0.20"), 0.20)
    wc = _to_float(os.getenv("W_CYCLE","0.15"), 0.15)
    wp = _to_float(os.getenv("W_PACE", "0.25"), 0.25)
    wb = _to_float(os.getenv("W_BIAS", "0.10"), 0.10)
    ws = _to_float(os.getenv("W_SHIP", "0.10"), 0.10)
    # weight for base already baked via caller; we blend components onto base
    probs = ensemble_mix(base, [pj, pc, pp, pb, ps], weights=[wj, wc, wp, wb, ws])

    # flags
    flags = []
    for i in range(n):
        f = []
        for chunk in (fj, fc, fp, fb, fs):
            lab = chunk[i] if i < len(chunk) else ""
            if lab: f.append(lab)
        flags.append(" ".join([x for x in f if x]))
    return probs, flags, ctx