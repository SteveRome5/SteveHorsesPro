# ======================================================================
# FILE: steve_horses_pro.py
# PURPOSE: Generate fast "Old Board" and "Simple" HTML with non-flat Win%
#          using PF-35 features + TRAIN + TJ/Horse DB + Market or ML fallback.
# ======================================================================

from __future__ import annotations
import os as _os
import re as _re
import math as _math
import csv as _csv
import json as _json
import webbrowser as _wb
from pathlib import Path as _Path
from datetime import datetime as _dt
import html as _html

# ----- Paths ------------------------------------------------------------
_BASE = _Path(_os.getenv("HOME") or ".") / "Desktop" / "SteveHorsesPro"
OUT_DIR = _BASE / "outputs"
DATA_DIR = _BASE / "data"
OUT_DIR.mkdir(parents=True, exist_ok=True)
(DATA_DIR / "signals").mkdir(parents=True, exist_ok=True)

# ----- Env helpers ------------------------------------------------------
def _env_bool(k: str, default: bool=False) -> bool:
    v = (_os.getenv(k) or "").strip().lower()
    if not v:
        return default
    return v in {"1","true","yes","on","y"}

def _env_float(k: str, default: float) -> float:
    try:
        return float(_os.getenv(k, str(default)))
    except Exception:
        return default

def _today_iso() -> str:
    return _os.getenv("RUN_DATE") or _dt.now().strftime("%Y-%m-%d")

# ----- Majors + canon ---------------------------------------------------
def _canon_track(t: str) -> str:
    k = _re.sub(r"[^a-z0-9]+", " ", str(t or "").lower()).strip()
    if "belmont" in k and ("big a" in k or "aqueduct" in k):
        return "Aqueduct Racetrack"
    if "aqueduct" in k:
        return "Aqueduct Racetrack"
    if "belmont park" in k:
        return "Belmont Park"
    if "saratoga" in k:
        return "Saratoga Race Course"
    if "churchill" in k:
        return "Churchill Downs"
    if "keeneland" in k:
        return "Keeneland"
    if "gulfstream" in k:
        return "Gulfstream Park"
    if "santa anita" in k:
        return "Santa Anita Park"
    if "del mar" in k:
        return "Del Mar"
    if "oaklawn" in k:
        return "Oaklawn Park"
    if "fair grounds" in k:
        return "Fair Grounds"
    if "parx" in k:
        return "Parx Racing"
    if "woodbine" in k:
        return "Woodbine"
    if "monmouth" in k:
        return "Monmouth Park"
    if "tampa" in k:
        return "Tampa Bay Downs"
    if "laurel park" in k:
        return "Laurel Park"
    return str(t or "").strip()

def _majors_set() -> set[str]:
    env = (_os.getenv("MAJOR_TRACKS_ONLY") or "").strip()
    default = {
        "Aqueduct Racetrack","Belmont Park","Saratoga Race Course","Churchill Downs","Keeneland",
        "Gulfstream Park","Santa Anita Park","Del Mar","Oaklawn Park","Fair Grounds",
        "Parx Racing","Woodbine","Monmouth Park","Tampa Bay Downs",
    }
    if not env:
        return default
    return {_canon_track(x) for x in env.split(",") if x.strip()}

def _is_major(track: str) -> bool:
    if (_os.getenv("ALLOW_MINOR_TRACKS") or "").strip().lower() in {"1","true","yes","on","y"}:
        return True
    return _canon_track(track) in _majors_set()

# ----- Inputs -----------------------------------------------------------
def _pred_csv(date_iso: str) -> _Path:
    for name in (
        f"{date_iso}_horses_predictions.csv",
        f"{date_iso}_predictions.csv",
        f"predictions_{date_iso}.csv",
    ):
        p = OUT_DIR / name
        if p.exists():
            return p
    return OUT_DIR / f"{date_iso}_horses_predictions.csv"

def _load_rows(date_iso: str) -> list[dict]:
    p = _pred_csv(date_iso)
    if not p.exists():
        return []
    with p.open("r", encoding="utf-8", newline="") as fh:
        rdr = _csv.DictReader(fh)
        return list(rdr)

# ----- Odds/market helpers ---------------------------------------------
def _to_f(x, d=None):
    try:
        if x in (None, ""):
            return d
        return float(x)
    except Exception:
        return d

def _ml_str_to_prob(s) -> float|None:
    if s is None:
        return None
    t = str(s).strip()
    if not t:
        return None
    t = t.replace(" ", "")
    t = t.split("â€¢")[0]
    if t.lower() in {"even","ev","e"}:
        return 0.5
    m = _re.match(r"^(\d+(?:\.\d+)?)[/-](\d+(?:\.\d+)?)$", t)
    if m:
        num = float(m.group(1)); den = float(m.group(2))
        dec = 1.0 + (num/den)
        return max(1e-6, min(0.99, 1.0/dec))
    try:
        dec = float(t)
        if dec > 1.0:
            return max(1e-6, min(0.99, 1.0/dec))
    except Exception:
        pass
    return None

def _prob_from_market_or_ml(row: dict, field_size: int) -> float|None:
    mkt = _to_f(row.get("market_pct"), None)
    if mkt is not None and mkt > 0:
        return max(1e-6, min(0.99, mkt))
    for key in ("ml","ml_odds","morning_line","morning_line_odds","ml_frac","ml_dec"):
        v = row.get(key)
        if v is None or v == "":
            continue
        p = _ml_str_to_prob(v)
        if p is None:
            try:
                p = float(v)
                if 0 < p < 1:
                    return max(1e-6, min(0.99, p))
            except Exception:
                pass
        if p is not None:
            return max(1e-6, min(0.99, p))
    if field_size > 0:
        return max(1e-6, min(0.99, 1.0/field_size))
    return None

# ----- PF feature extraction -------------------------------------------
def _pct_to_z(p):
    try:
        p = float(p)
        if p <= 0 or p >= 100:
            return 0.0 if p == 50 else (3.0 if p > 50 else -3.0)
        p /= 100.0
        z = _math.log((p+1e-6)/(1-p+1e-6)) * 0.5513
        return max(-3.5, min(3.5, z))
    except Exception:
        return 0.0

def _get_sf_z(r: dict) -> float:
    for k in ("speed_z","sf_z","speedform_z","SpeedFormZ","speed_pct","SpeedFormPct"):
        if k in r and r[k] not in ("", None):
            v = r[k]
            if "pct" in k.lower():
                return _pct_to_z(v)
            f = _to_f(v, None)
            return f if f is not None else 0.0
    return 0.0

def _get_cd_z(r: dict) -> float:
    for k in ("class_z","class_delta_z","ClassDeltaZ","class_pct","ClassDeltaPct"):
        if k in r and r[k] not in ("", None):
            v = r[k]
            if "pct" in k.lower():
                return _pct_to_z(v)
            f = _to_f(v, None)
            return f if f is not None else 0.0
    return 0.0

def _get_bias_z(r: dict) -> float:
    for k in ("bias_z","BiasZ","bias_sigma","bias_pct"):
        if k in r and r[k] not in ("", None):
            v = r[k]
            if "pct" in k.lower():
                return _pct_to_z(v)
            f = _to_f(v, None)
            return f if f is not None else 0.0
    return 0.0

# ----- Optional DBs -----------------------------------------------------
try:
    import db_tj as _db_tj
except Exception:
    _db_tj = None

try:
    import db_horses as _db_horses
except Exception:
    _db_horses = None

def _tj_z_and_mark(trainer: str|None, jockey: str|None, track: str|None) -> tuple[float,str]:
    if _db_tj is None:
        return 0.0, ""
    try:
        rec = _db_tj.lookup_combo(trainer or "", jockey or "", track or "", None, None) or {}
        wr = float(rec.get("win_pct") or 0.0)
        n  = int(rec.get("starts") or 0)
        z  = _pct_to_z(min(99.9, max(0.1, wr)))
        mark = f"TJ {wr:.0f}%/{n}" if n >= 40 else ""
        return z, mark
    except Exception:
        return 0.0, ""

def _db_count_horse(horse: str|None) -> int:
    if _db_horses is None or not horse:
        return 0
    try:
        return int(_db_horses.count_hist(horse))
    except Exception:
        return 0

# ----- TRAIN signals ----------------------------------------------------
_SIG_CACHE: dict[tuple[str,str], list[dict]] = {}

def _load_signals_for(track: str, date_iso: str) -> list[dict]:
    key = (track, date_iso)
    if key in _SIG_CACHE:
        return _SIG_CACHE[key]
    p = DATA_DIR / "signals" / f"{track}|{date_iso}.json"
    try:
        arr = _json.loads(p.read_text(encoding="utf-8")) if p.exists() else []
    except Exception:
        arr = []
    _SIG_CACHE[key] = arr
    return arr

def _sig_used(track: str, race: str|int, program: str, date_iso: str) -> bool:
    try:
        arr = _load_signals_for(track, date_iso)
        rr = int(_re.sub(r"[^\d]", "", str(race) or "0") or 0)
        pg = str(program or "").strip()
        for row in arr:
            if str(row.get("program","")).strip() == pg and int(row.get("race") or 0) == rr:
                return bool(row.get("used"))
    except Exception:
        pass
    return False

# ----- Grouping ---------------------------------------------------------
def _group_by_race(rows: list[dict]) -> dict[tuple[str,str], list[dict]]:
    by: dict[tuple[str,str], list[dict]] = {}
    for r in rows:
        t = r.get("track","")
        if not _is_major(t):
            continue
        key = (t, str(r.get("race","")))
        by.setdefault(key, []).append(r)
    return by

# ----- Prob math --------------------------------------------------------
def _logit(p: float) -> float:
    p = max(1e-6, min(1-1e-6, p))
    return _math.log(p/(1-p))

def _softmax(xs: list[float]) -> list[float]:
    if not xs:
        return []
    m = max(xs)
    es = [_math.exp(x-m) for x in xs]
    s = sum(es) or 1.0
    return [e/s for e in es]

# ----- Scoring ----------------------------------------------------------
_W = {
    "b0": 0.00,
    "sf": 1.50,
    "cd": 1.20,
    "bias": 0.80,
    "tj": 0.55,
    "train": 0.70,
    "db": 0.25,
}
try:
    _W.update(_json.loads(_os.getenv("PRO_WEIGHTS_JSON","{}")))
except Exception:
    pass

_PRO_ALPHA   = _env_float("PRO_ALPHA", 1.30)
_USE_SHARP   = _env_bool("PRO_USE_SHARP", True)
_PRIOR_W     = _env_float("PRO_PRIOR_W", 0.90)
_PRIOR_ML_B  = _env_float("PRO_PRIOR_ML_B", 1.00)
_EDGE_FLOOR  = _env_float("EDGE_WIN_PCT_FLOOR", 0.20)
_EDGE_PP_MIN = _env_float("EDGE_PP_MIN_PRIME", 3.0)

def _PRIORDOT(prior: float) -> float:
    return _PRIOR_W * _logit(prior)

def _score_runner(track: str, race: str|int, r: dict, field_size: int, date_iso: str) -> dict:
    sf = _get_sf_z(r)
    cd = _get_cd_z(r)
    bz = _get_bias_z(r)
    tr = r.get("trainer") or r.get("trainer_name")
    jk = r.get("jockey")  or r.get("jockey_name")
    tjz, tjm = _tj_z_and_mark(tr, jk, track)
    prog  = str(r.get("program") or r.get("prog") or "")
    used  = _sig_used(track, race, prog, date_iso)
    ndb   = _db_count_horse(r.get("horse"))
    prior = _prob_from_market_or_ml(r, field_size) or max(1e-6, min(0.99, 1.0/max(1, field_size)))
    prior = max(1e-6, min(0.99, prior)) ** _PRIOR_ML_B
    score = (_W["b0"] + _W["sf"]*sf + _W["cd"]*cd + _W["bias"]*bz + _W["tj"]*tjz
             + _W["train"]*(1.0 if used else 0.0) + _W["db"]*_math.log1p(ndb)
             + _PRIORDOT(prior))
    return {
        "sf": sf, "cd": cd, "bz": bz, "tj_z": tjz, "tj_mark": tjm,
        "train_used": used, "db_n": int(ndb), "prior": prior,
        "program": prog, "horse": r.get("horse",""),
        "score": score, "pm": 0.0, "pu": 0.0,
        "market_pct": _to_f(r.get("market_pct"), None),
        "mlp": _ml_str_to_prob(r.get("ml") or r.get("ml_odds") or r.get("morning_line") or r.get("morning_line_odds"))
    }

def _race_probs(scored: list[dict]) -> tuple[list[float], list[float]]:
    raw = [x["score"] for x in scored]
    p_model = _softmax(raw)
    if abs(_PRO_ALPHA - 1.0) < 1e-6:
        p_use = p_model[:]
    else:
        p_pow = [max(1e-12, p)**_PRO_ALPHA for p in p_model]
        s = sum(p_pow) or 1.0
        p_use = [p/s for p in p_pow]
    return p_model, p_use

# ----- Rendering: Old Board --------------------------------------------
def _write_old_board_html(date_iso: str) -> None:
    rows = _load_rows(date_iso)
    if not rows:
        return
    groups = _group_by_race(rows)
    parts: list[str] = []
    parts.append("<!doctype html><html><head><meta charset='utf-8'>")
    parts.append("<title>PRO Old Board â€” " + date_iso + "</title>")
    parts.append("<style>body{font-family:-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px}"
                 "table{border-collapse:collapse;width:100%;margin:12px 0}"
                 "th,td{border:1px solid #ddd;padding:6px 8px;text-align:left;font-size:13px}"
                 "th{background:#f3f3f3}.yes{background:#e7f7ea}.no{background:#f7e7e7}.mono{font-variant-numeric:tabular-nums}"
                 ".small{font-size:12px;color:#666}</style></head><body>")
    parts.append("<h1>Old Board <span class='small'>(" + date_iso + ")</span></h1>")
    parts.append("<p class='small mono'>PF-35 + TRAIN + DB + Market/ML. Î±=" + str(_PRO_ALPHA) +
                 " use_sharp=" + str(bool(_USE_SHARP)) + "</p>")

    def _num(s):
        try: return int(_re.sub(r"[^\d]","", str(s)) or "0")
        except Exception: return 0

    for (track, race), arr in sorted(groups.items(), key=lambda kv: (_canon_track(kv[0][0]).lower(), _num(kv[0][1]))):
        field_size = len(arr)
        scored = [_score_runner(track, race, r, field_size, date_iso) for r in arr]
        pm, pu = _race_probs(scored)
        for x, pmi, pui in zip(scored, pm, pu):
            x["pm"], x["pu"] = pmi, pui

        parts.append("<h2>{} â€” Race {} <span class='small mono'>(n={}, Î£p={:.3f})</span></h2>".format(
            track, race, field_size, sum(x["pu"] if _USE_SHARP else x["pm"] for x in scored)
        ))

        parts.append("".join([
            "<table><thead><tr>",
            "<th>Prog</th><th>Horse</th>",
            "<th class='mono'>p_model</th>",
            "<th class='mono'>p_sharp</th>" if _USE_SHARP else "",
            "<th class='mono'>Fair</th>",
            "<th class='mono'>Market%</th><th class='mono'>ML%</th>",
            "<th class='mono'>Overlay(pp)</th>",
            "<th>Flags</th>",
            "<th class='mono'>Bet?</th>",
            "</tr></thead><tbody>",
        ]))

        def _fair(p): return (1.0/max(1e-9,p))
        def _overlay(p, m): return (p - (m if m is not None else 0.0)) * 100.0

        enriched = []
        for x in scored:
            p_use = x["pu"] if _USE_SHARP else x["pm"]
            fair = _fair(p_use)
            refm = x["market_pct"] if x["market_pct"] is not None else x["mlp"]
            ov = _overlay(p_use, refm)
            flags = "PF: SF{:+.2f} CD{:+.2f} Bias{:+.2f} | TRAIN:{} | {} | DB:{}".format(
                x["sf"], x["cd"], x["bz"],
                ("Y" if x["train_used"] else "â€”"),
                (x["tj_mark"] if x["tj_mark"] else "TJâ€”"),
                x["db_n"]
            )
            dec = "YES" if (p_use >= _EDGE_FLOOR and ov >= _EDGE_PP_MIN) else "NO"
            enriched.append((ov, -p_use, x, fair, dec, flags, refm))

        enriched.sort(reverse=True)
        for _, __, x, fair, dec, flags, refm in enriched:
            parts.append("".join([
                "<tr class='", ("yes" if dec=="YES" else "no"), "'>",
                "<td class='mono'>", _html.escape(x["program"]), "</td>",
                "<td>", _html.escape(x["horse"]), "</td>",
                "<td class='mono'>", "{:.3f}".format(x["pm"]), "</td>",
                ("<td class='mono'>"+("{:.3f}".format(x["pu"]))+"</td>" if _USE_SHARP else ""),
                "<td class='mono'>", "{:.2f}".format(fair if fair < 999 else 999.0), "</td>",
                "<td class='mono'>", "{:.3f}".format(x["market_pct"] if x["market_pct"] is not None else 0.0), "</td>",
                "<td class='mono'>", "{:.3f}".format(x["mlp"] if x["mlp"] is not None else 0.0), "</td>",
                "<td class='mono'>", "{:+.1f}".format(ov), "</td>",
                "<td>", flags, "</td>",
                "<td class='mono'><b>", dec, "</b></td>",
                "</tr>"
            ]))

        parts.append("</tbody></table>")

    parts.append("<p class='small'>Generated " + _dt.now().strftime('%Y-%m-%d %H:%M:%S') +
                 " | Î±="+str(_PRO_ALPHA) + " | majors_only=" +
                 ("no" if (_os.getenv("ALLOW_MINOR_TRACKS") or "").strip().lower() in {"1","true","yes","on","y"} else "yes") +
                 "</p></body></html>")

    html = "\n".join(parts)
    (OUT_DIR / "latest-board.html").write_text(html, encoding="utf-8")
    (OUT_DIR / (date_iso + "_board.html")).write_text(html, encoding="utf-8")

# ----- Rendering: Simple YES/NO ----------------------------------------
def _write_simple_bets_html(date_iso: str) -> None:
    rows = _load_rows(date_iso)
    if not rows:
        return
    groups = _group_by_race(rows)
    parts = []
    parts.append("<!doctype html><html><head><meta charset='utf-8'>")
    parts.append("<title>PRO Simple Bets â€” " + date_iso + "</title>")
    parts.append("<style>body{font-family:-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px}"
                 "table{border-collapse:collapse;width:100%;margin:12px 0}"
                 "th,td{border:1px solid #ddd;padding:6px 8px;text-align:left;font-size:14px}"
                 "th{background:#f3f3f3}.yes{background:#e7f7ea}.no{background:#f7e7e7}.mono{font-variant-numeric:tabular-nums}</style>")
    parts.append("</head><body>")
    parts.append("<h1>Bet Decisions <span style='font-size:12px;color:#666'>(" + date_iso + ")</span></h1>")
    parts.append("<p class='mono' style='color:#666'>PF-35 + TRAIN + DB; Market% or ML fallback.</p>")

    def _num(s):
        try: return int(_re.sub(r"[^\d]","", str(s)) or "0")
        except Exception: return 0

    for (track, race), arr in sorted(groups.items(), key=lambda kv: (_canon_track(kv[0][0]).lower(), _num(kv[0][1]))):
        field_size = len(arr)
        scored = [_score_runner(track, race, r, field_size, date_iso) for r in arr]
        pm, pu = _race_probs(scored)
        for x, pmi, pui in zip(scored, pm, pu):
            x["pm"], x["pu"] = pmi, pui

        parts.append("<h2>{} â€” Race {}</h2>".format(track, race))
        parts.append("<table><thead><tr><th>Prog</th><th>Horse</th><th>p</th><th>mkt/ML</th><th>edge(pp)</th><th>Flags</th><th>Bet?</th></tr></thead><tbody>")

        enriched = []
        for x in scored:
            p_use = x["pu"] if _USE_SHARP else x["pm"]
            ref = x["market_pct"] if x["market_pct"] is not None else x["mlp"]
            ref = ref if ref is not None else 0.0
            edge_pp = (p_use - ref) * 100.0
            flags = "PF SF{:+.2f} CD{:+.2f} B{:+.2f} | TRAIN:{} | {} | DB:{}".format(
                x["sf"], x["cd"], x["bz"], ("Y" if x["train_used"] else "â€”"),
                (x["tj_mark"] if x["tj_mark"] else "TJâ€”"), x["db_n"]
            )
            dec = "YES" if (p_use >= _EDGE_FLOOR and edge_pp >= _EDGE_PP_MIN) else "NO"
            enriched.append((edge_pp, -p_use, x, p_use, ref, dec, flags))

        enriched.sort(reverse=True)
        for _, __, x, p_use, ref, dec, flags in enriched:
            cls = "yes" if dec == "YES" else "no"
            parts.append("".join([
                "<tr class='", cls, "'>",
                "<td class='mono'>", _html.escape(x["program"]), "</td>",
                "<td>", _html.escape(x["horse"]), "</td>",
                "<td class='mono'>", "{:.3f}".format(p_use), "</td>",
                "<td class='mono'>", "{:.3f}".format(ref), "</td>",
                "<td class='mono'>", "{:+.1f}".format((p_use - ref) * 100.0), "</td>",
                "<td class='mono'>", _html.escape(flags), "</td>",
                "<td class='mono'><b>", dec, "</b></td>",
                "</tr>"
            ]))
        parts.append("</tbody></table>")
    parts.append("</body></html>")
    html = "\n".join(parts)
    (OUT_DIR / "latest-simple.html").write_text(html, encoding="utf-8")
    (OUT_DIR / (date_iso + "_simple_bets.html")).write_text(html, encoding="utf-8")

# ----- Main -------------------------------------------------------------
if __name__ == "__main__":
    iso = _today_iso()
    _write_old_board_html(iso)
    _write_simple_bets_html(iso)
    if _env_bool("AUTO_OPEN", True):
        try:
            _wb.open((OUT_DIR / "latest-board.html").as_uri())
        except Exception:
            pass
